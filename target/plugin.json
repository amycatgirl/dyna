{"namespace":"amycatgirl","id":"dyna-devel","version":7,"dyna":{"repo":"amycatgirl/dyna-testing","shouldRestart":true,"dev":false},"entrypoint":"() => {\n\t/**\n\t * Dyna plugin information, should contain latest version to compare against\n\t * @typedef {Object} DynaPluginInformation\n\t * @property {string} version - Latest version of the plugin\n\t * @property {string} [target=\"plugin.json\"] - Optional target to download the plugin\n\t */\n\n\t/**\n\t * Information about a currently loaded plugin\n\t * @typedef {Object} DynaPlugin\n\t * @property {string} author- Namespace of the plugin, usually the author's username.\n\t * @property {string} id- Id of the plugin.\n\t * @property {number} repo - Location of the plugin's repository.\n\t * @property {int} version - Currently loaded version.\n\t * @property {boolean} [dev=false] - Whether the plugin is currently running in developer mode.\n\t * @property {boolean} [shouldRestart=false] - Whether the manager should reload the client when the plugin is updated.\n\t */\n\n\tclass UpdateIndicator extends HTMLElement {\n\t\tconstructor() {\n\t\t\tsuper();\n\t\t\tthis._template = `\n\t\t\t\t<div class=\"dyna popup updateInfo\">\n\t\t\t\t\t<progress id=\"updateProgress\" max=1 value=.5></progress>\n\t\t\t\t\t<div class=\"information\">\n\t\t\t\t\t\t<h2 id=\"progressText\">Please wait...</h2>\n\t\t\t\t\t\t<header>\n\t\t\t\t\t\t\t<span>dyna</span>\n\t\t\t\t\t\t</header>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t`\n\n\t\t\tthis._styles = `\n\t\t\t\t.dyna.popup {\n\t\t\t\t\t--offset: 10px;\n\n\t\t\t\t\tfont-family: sans-serif;\n\n\t\t\t\t\tposition: absolute;\n\t\t\t\t\ttop: var(--offset);\n\t\t\t\t\tright: var(--offset);\n\t\t\t\t\tdisplay: flex;\n\t\t\t\t\tflex-flow: column nowrap;\n\t\t\t\t\tborder-radius: 10px;\n\t\t\t\t\toverflow: clip;\n\n\t\t\t\t\tbackground: rgba(var(--primary-background-rgb), .5);\n\t\t\t\t\tbackdrop-filter: blur(5px);\n\t\t\t\t\tcolor: var(--foreground);\n\t\t\t\t}\n\n\t\t\t\t.dyna.popup.updateInfo .information {\n\t\t\t\t\tpadding: 10px;\n\t\t\t\t}\n\n\t\t\t\t.dyna.popup.updateInfo progress {\n\t\t\t\t\t-webkit-appearance: none;\n\t\t\t\t\tappearance: none;\n\n\t\t\t\t\twidth: 100%;\n\t\t\t\t}\n\n\n\t\t\t\t.dyna.popup.updateInfo progress::-webkit-progress-value {\n\t\t\t\t\tbackground: var(--accent);\n\t\t\t\t\ttransition: all 1s ease-in-out;\n\t\t\t\t}\n\n\t\t\t\t.dyna.popup.updateInfo progress::-webkit-progress-bar {\n\t\t\t\t\tbackground: transparent;\n\t\t\t\t}\n\n\t\t\t\t.dyna.popup.updateInfo h2 {\n\t\t\t\t\tmargin: 0 0 10px 0;\n\t\t\t\t}\n\n\t\t\t\t.dyna.popup.updateInfo header>span {\n\t\t\t\t\tcolor: var(--tertiary-foreground);\n\t\t\t\t\tfont-style: italic;\n\t\t\t\t}\n\n\t\t\t\t.slidein {\n\t\t\t\t\tanimation-name: slide;\n\t\t\t\t\tanimation-fill-mode: forwards;\n\t\t\t\t\tanimation-duration: 1s;\n\t\t\t\t\tanimation-timing-function: ease-in-out;\n\t\t\t\t}\n\n\t\t\t\t.slideout {\n\t\t\t\t\tanimation-name: slide;\n\t\t\t\t\tanimation-direction: reverse;\n\t\t\t\t\tanimation-duration: 1s;\n\t\t\t\t\tanimation-timing-function: ease-in-out;\n\t\t\t\t}\n\n\t\t\t\t@keyframes slide {\n\t\t\t\t\tfrom {\n\t\t\t\t\t\ttransform: translateX(500px);\n\t\t\t\t\t}\n\n\t\t\t\t\tto {\n\t\t\t\t\t\ttransform: translateX(0px);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`\n\t\t}\n\n\t\tconnectedCallback() {\n\t\t\tconst shadow = this.attachShadow({ mode: \"open\" })\n\t\t\tconst style = new CSSStyleSheet()\n\t\t\tstyle.replaceSync(this._styles);\n\t\t\tshadow.innerHTML = this._template\n\t\t\tshadow.adoptedStyleSheets = [style]\n\t\t}\n\n\t\tupdateProgress(int) {\n\t\t\tconst shadowDOM = this.shadowRoot\n\t\t\tshadowDOM.getElementById(\"updateProgress\").value = int\n\t\t}\n\n\t\tupdateProgressInformation(amount) {\n\t\t\tconst shadowDom = this.shadowRoot\n\t\t\tshadowDom.getElementById(\"progressText\").innerText = `Updating ${amount} plugins`\n\t\t}\n\n\t\tslide(dir) {\n\t\t\tconst shadowDom = this.shadowRoot\n\t\t\tshadowDom.querySelector('.dyna.popup.updateInfo').classList.add(`slide${dir}`)\n\n\t\t\tsetTimeout(() => shadowDom.querySelector('.dyna.popup.updateInfo').classList.remove(`slide${dir}`), 1000);\n\t\t}\n\n\t\tfinished() {\n\t\t\tconst shadowDom = this.shadowRoot\n\t\t\tshadowDom.getElementById(\"progressText\").innerText = `All plugins have been updated!`\n\t\t}\n\t}\n\n\tif (!customElements.get('dyna-indicator')){\n\t\tcustomElements.define('dyna-indicator', UpdateIndicator)\n\t}\n\n\t/** Dyna */\n\twindow.dyna = {};\n\n\t/**\n\t * Dyna's store. It stores currently loaded plugins and the interval on which the plugins should be updated\n\t * Default interval is 1h\n\t * @type {{ dynaplugins: DynaPlugin[], updateInterval: number }}\n\t */\n\twindow.dyna.store = { dynaplugins: [], updateInterval: 3600 }\n\n\t/** Convert the interval from seconds to milliseconds */\n\tconst CALCULATED_INTERVAL = window.dyna.store.updateInterval * 1000;\n\n\t/** Used for the loading indicator, which is not implemented yet */\n\tlet updateProgress = 0;\n\n\n\t/**\n\t * Internal API - Fetch a remote resourse whilst logging it's progress.\n\t * Percentage streaming is planned\n\t */\n\tasync function fetchWithProgress(url) {\n\t\tconst xhr = new XMLHttpRequest();\n\t\treturn await new Promise((resolve) => {\n\t\t\txhr.addEventListener(\"progress\", (event) => {\n\t\t\t\tif (event.lengthComputable) {\n\t\t\t\t\tconsole.log(\"Downloading:\", `${(event.loaded / event.total) * 100}%`);\n\t\t\t\t}\n\t\t\t});\n\t\t\txhr.addEventListener(\"loadend\", () => {\n\t\t\t\tif (xhr.readyState === 4 && xhr.status === 200) {\n\t\t\t\t\tresolve(xhr.responseText);\n\t\t\t\t}\n\t\t\t});\n\t\t\txhr.open(\"GET\", url);\n\t\t\txhr.send();\n\t\t});\n\t}\n\n\t/**\n\t * Internal API - Update dyna's plugin store\n\t */\n\tfunction gatherPluginsFromState() {\n\t\t// Reset store because it's going to be recalculated\n\t\tif (window.dyna.store.dynaplugins.length > 0) {\n\t\t\twindow.dyna.store.dynaplugins.length = 0\n\t\t}\n\n\t\tconst data = state.plugins.plugins.data_; // map of K=name+instance, V=plugin\n\t\tfor (const [key, value] of data.entries()) {\n\t\t\tif (value.value_.dyna) {\n\t\t\t\tif (value.value_.namespace === \"amycatgirl\" && (value.value_.id === \"dyna-devel\" || value.value_.id === \"dyna\") && value.value_.dyna.dev) {\n\t\t\t\t\tallowDebugging()\n\t\t\t\t}\n\n\t\t\t\twindow.dyna.store.dynaplugins.push({\n\t\t\t\t\t...value.value_.dyna,\n\t\t\t\t\tversion: value.value_.version,\n\t\t\t\t\tauthor: value.value_.namespace,\n\t\t\t\t\tid: value.value_.id\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tconsole.log(\"Plugins using dyna:\", window.dyna.store.dynaplugins.length)\n\t}\n\n\t/**\n\t * Not implemented - Show a modal prompting the user to restart their client\n\t */\n\tfunction restartWithModalWarning() {\n\t\tconsole.log(\"TODO\")\n\t}\n\n\t/**\n\t * Internal API - Fetch plugin information from Github\n\t * @param {string} repo - Plugin's repository\n\t * @returns {DnyaPluginInformation}\n\t */\n\tasync function fetchPluginInformation(repo) {\n\t\ttry {\n\t\t\tconst res = fetch(`https://raw.githubusercontent.com/${repo}/main/dyna.json`).then(async (res) => await res.json())\n\n\t\t\treturn res\n\t\t} catch (err) {\n\t\t\tconsole.error(\"Error getting plugin information for repo:\", repo)\n\t\t}\n\t}\n\n\t/**\n\t * Internal API - Parse and load plugins, also handle syntax errors/plugin errors\n\t * @param {string} pl - Plugin manifest, in the form of a stringified json object\n\t */\n\tfunction parseAndLoadPlugin(pl) {\n\t\ttry {\n\t\t\tconst plugin = JSON.parse(pl)\n\t\t\tconsole.log(\"PARSED\", plugin)\n\t\t\twindow.state.plugins.add(plugin)\n\t\t} catch(err) {\n\t\t\tconsole.error(\"Could not load plugin:\", err)\n\t\t}\n\t}\n\n\t/**\n\t * Internal API - Update all installed plugins.\n\t */\n\tasync function updateAllPlugins() {\n\t\t// Check if the store isn't empty or was initialized incorrectly\n\t\tif (window.dyna.store.dynaplugins.length == 0) {\n\t\t\tgatherPluginsFromState()\n\t\t}\n\n\t\tconst indicator = window.document.createElement(\"dyna-indicator\")\n\t\twindow.document.body.appendChild(indicator)\n\t\tindicator.updateProgressInformation(window.dyna.store.dynaplugins.length)\n\t\tindicator.slide(\"in\")\n\n\t\tlet shouldRestart = false;\n\t\tfor await (const [index, plugin] of window.dyna.store.dynaplugins.entries()) {\n\t\t\tconst info = await fetchPluginInformation(plugin.repo)\n\t\t\tif (info.latest > plugin.version) {\n\t\t\t\tif (plugin.dev) {\n\t\t\t\t\tconsole.log(\"plugin in dev mode, not updating\")\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (plugin.shouldRestart) {\n\t\t\t\t\tshouldRestart = true\n\t\t\t\t};\n\n\t\t\t\ttry {\n\t\t\t\t\tconst updatedPlugin = await fetchWithProgress(`https://raw.githubusercontent.com/${plugin.repo}/main/${info.target ?? \"plugin.json\"}`)\n\t\t\t\t\tparseAndLoadPlugin(updatedPlugin)\n\t\t\t\t} catch(err) {\n\t\t\t\t\tconsole.error(err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.log(\"Plugin is up-to-date :)\")\n\t\t\t}\n\n\t\t\tupdateProgress = ((index + 1) / window.dyna.store.dynaplugins.length) * 100\n\t\t\tindicator.updateProgress(updateProgress)\n\t\t\tconsole.log(`Progress: ${updateProgress}%`)\n\t\t}\n\n\t\tif (shouldRestart) {\n\t\t\t// TODO: Replace with restartWithModalWarning\n\t\t\twindow.alert(\"RELOADING\")\n\t\t\twindow.location.reload();\n\t\t}\n\n\t\t// Remove indicator as all plugins have updated\n\t\tindicator.finished()\n\t\tsetTimeout(() => indicator.slide(\"out\"), 4000);\n\t\tsetTimeout(() => indicator.remove(), 5000);\n\t}\n\n\tfunction InternalArtificialDelay(callback) {\n\t\tsetTimeout(callback, 5000)\n\t}\n\n\t/**\n\t * Internal API - Expose internal APIs to debug dyna\n\t */\n\tfunction allowDebugging() {\n\t\t// Only for debugging purposes\n\t\twindow.dyna.debug = {};\n\t\twindow.dyna.debug.updatePluginsForced = updateAllPlugins;\n\t\twindow.dyna.debug.updateStore = gatherPluginsFromState;\n\t\twindow.dyna.debug.fetch = fetchWithProgress;\n\t\twindow.dyna.debug.parse = parseAndLoadPlugin;\n\t\twindow.dyna.debug.getPluginInformation = fetchPluginInformation;\n\t}\n\n\t/**\n\t * Dyna plugin API\n\t */\n\twindow.dyna.api = {}\n\n\t/**\n\t * Returns an array of plugins that are using Dyna\n\t * @returns {DynaPlugin[]}\n\t */\n\twindow.dyna.api.getPlugins = function () {\n\t\tconst pluginArray = window.dyna.store.dynaplugins;\n\t\treturn Object.freeze(pluginArray)\n\t}\n\n\t/**\n\t * Check for plugin updates\n\t * @param {string} author - Author of the plugin to search\n\t * @param {string} id - Id of the plugin to search\n\t * @returns {boolean} whether the plugin needs an update or the check has failed\n\t */\n\twindow.dyna.api.checkUpdatesForPlugin = async function (author, id) {\n\t\ttry {\n\t\t\tconst plugin = window.dyna.store.dynaplugins.find(pl => pl.author == author && pl.id == id);\n\n\t\t\t/** @type {DynaPluginInformation} */\n\t\t\tconst information = await fetchPluginInformation(plugin.repo)\n\n\t\t\tif (plugin.version != information.latest && !plugin.dev) {\n\t\t\t\tconsole.log(`[updater] An update has been found for the plugin ${author}/${id}`);\n\t\t\t\treturn true\n\t\t\t}\n\n\t\t\tconsole.log(`[updater] No update has been found...`)\n\t\t\treturn false\n\t\t} catch (error) {\n\t\t\tconsole.error(\"[updater] An error has been thrown:\", error)\n\t\t\treturn false\n\t\t}\n\t}\n\n\tsetInterval(updateAllPlugins, CALCULATED_INTERVAL)\n\tsetTimeout(gatherPluginsFromState, 500) // Let plugins load successfully\n\n\treturn  {\n\t\tonUnload: () => {\n\t\t\t// Unload dyna by removing the update interval and removing all related APIs from the window object\n\t\t\tclearInterval(updateAllPlugins, CALCULATED_INTERVAL)\n\t\t\twindow.dyna = null\n\t\t\tconsole.log(\"DYNA has been unloaded...\")\n\t\t}\n\t}\n}\n"}
