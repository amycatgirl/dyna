{"namespace":"amycatgirl","id":"dyna-devel","version":6,"dyna":{"repo":"amycatgirl/dyna-testing","shouldRestart":true,"dev":false},"entrypoint":"() => {\n\t/**\n\t * Dyna plugin information, should contain latest version to compare against\n\t * @typedef {Object} DynaPluginInformation\n\t * @property {string} version - Latest version of the plugin\n\t * @property {string} [target=\"plugin.json\"] - Optional target to download the plugin\n\t */\n\n\t/**\n\t * Information about a currently loaded plugin\n\t * @typedef {Object} DynaPlugin\n\t * @property {string} author- Namespace of the plugin, usually the author's username.\n\t * @property {string} id- Id of the plugin.\n\t * @property {number} repo - Location of the plugin's repository.\n\t * @property {int} version - Currently loaded version.\n\t * @property {boolean} [dev=false] - Whether the plugin is currently running in developer mode.\n\t * @property {boolean} [shouldRestart=false] - Whether the manager should reload the client when the plugin is updated.\n\t */\n\n\t/** Dyna */\n\twindow.dyna = {};\n\n\t/**\n\t * Dyna's store. It stores currently loaded plugins and the interval on which the plugins should be updated\n\t * Default interval is 1h\n\t * @type {{ dynaplugins: DynaPlugin[], updateInterval: number }}\n\t */\n\twindow.dyna.store = { dynaplugins: [], updateInterval: 3600 }\n\n\t/** Convert the interval from seconds to milliseconds */\n\tconst CALCULATED_INTERVAL = window.dyna.store.updateInterval * 1000;\n\n\t/** Used for the loading indicator, which is not implemented yet */\n\tlet updateProgress = 0;\n\n\n\t/**\n\t * Internal API - Fetch a remote resourse whilst logging it's progress.\n\t * Percentage streaming is planned\n\t */\n\tasync function fetchWithProgress(url) {\n\t\tconst xhr = new XMLHttpRequest();\n\t\treturn await new Promise((resolve) => {\n\t\t\txhr.addEventListener(\"progress\", (event) => {\n\t\t\t\tif (event.lengthComputable) {\n\t\t\t\t\tconsole.log(\"Downloading:\", `${(event.loaded / event.total) * 100}%`);\n\t\t\t\t}\n\t\t\t});\n\t\t\txhr.addEventListener(\"loadend\", () => {\n\t\t\t\tif (xhr.readyState === 4 && xhr.status === 200) {\n\t\t\t\t\tresolve(xhr.responseText);\n\t\t\t\t}\n\t\t\t});\n\t\t\txhr.open(\"GET\", url);\n\t\t\txhr.send();\n\t\t});\n\t}\n\n\t/**\n\t * Internal API - Update dyna's plugin store\n\t */\n\tfunction gatherPluginsFromState() {\n\t\t// Reset store because it's going to be recalculated\n\t\tif (window.dyna.store.dynaplugins.length > 0) {\n\t\t\twindow.dyna.store.dynaplugins.length = 0\n\t\t}\n\n\t\tconst data = state.plugins.plugins.data_; // map of K=name+instance, V=plugin\n\t\tfor (const [key, value] of data.entries()) {\n\t\t\tif (value.value_.dyna) {\n\t\t\t\tif (value.value_.namespace === \"amycatgirl\" && (value.value_.id === \"dyna-devel\" || value.value_.id === \"dyna\") && value.value_.dyna.dev) {\n\t\t\t\t\tallowDebugging()\n\t\t\t\t}\n\n\t\t\t\twindow.dyna.store.dynaplugins.push({\n\t\t\t\t\t...value.value_.dyna,\n\t\t\t\t\tversion: value.value_.version,\n\t\t\t\t\tauthor: value.value_.namespace,\n\t\t\t\t\tid: value.value_.id\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tconsole.log(\"Plugins using dyna:\", window.dyna.store.dynaplugins.length)\n\t}\n\n\t/**\n\t * Not implemented - Show a modal prompting the user to restart their client\n\t */\n\tfunction restartWithModalWarning() {\n\t\tconsole.log(\"TODO\")\n\t}\n\n\t/**\n\t * Internal API - Fetch plugin information from Github\n\t * @param {string} repo - Plugin's repository\n\t * @returns {DnyaPluginInformation}\n\t */\n\tasync function fetchPluginInformation(repo) {\n\t\ttry {\n\t\t\tconst res = fetch(`https://raw.githubusercontent.com/${repo}/main/dyna.json`).then(async (res) => await res.json())\n\n\t\t\treturn res\n\t\t} catch (err) {\n\t\t\tconsole.error(\"Error getting plugin information for repo:\", repo)\n\t\t}\n\t}\n\n\t/**\n\t * Internal API - Parse and load plugins, also handle syntax errors/plugin errors\n\t * @param {string} pl - Plugin manifest, in the form of a stringified json object\n\t */\n\tfunction parseAndLoadPlugin(pl) {\n\t\ttry {\n\t\t\tconst plugin = JSON.parse(pl)\n\t\t\tconsole.log(\"PARSED\", plugin)\n\t\t\twindow.state.plugins.add(plugin)\n\t\t} catch(err) {\n\t\t\tconsole.error(\"Could not load plugin:\", err)\n\t\t}\n\t}\n\n\n\t/**\n\t * Internal API - Update all installed plugins.\n\t */\n\tasync function updateAllPlugins() {\n\t\t// Check if the store isn't empty or was initialized incorrectly\n\t\tif (window.dyna.store.dynaplugins.length == 0) {\n\t\t\tgatherPluginsFromState()\n\t\t}\n\n\t\tlet shouldRestart = false;\n\t\tfor await (const [index, plugin] of window.dyna.store.dynaplugins.entries()) {\n\t\t\tconst info = await fetchPluginInformation(plugin.repo)\n\t\t\tif (info.latest > plugin.version) {\n\t\t\t\tif (plugin.dev) {\n\t\t\t\t\tconsole.log(\"plugin in dev mode, not updating\")\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (plugin.shouldRestart) {\n\t\t\t\t\tshouldRestart = true\n\t\t\t\t};\n\n\t\t\t\ttry {\n\t\t\t\t\tconst updatedPlugin = await fetchWithProgress(`https://raw.githubusercontent.com/${plugin.repo}/main/${info.target ?? \"plugin.json\"}`)\n\t\t\t\t\tparseAndLoadPlugin(updatedPlugin)\n\t\t\t\t} catch(err) {\n\t\t\t\t\tconsole.error(err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.log(\"Plugin is up-to-date :)\")\n\t\t\t}\n\n\t\t\tupdateProgress = ((index + 1) / window.dyna.store.dynaplugins.length) * 100\n\t\t\tconsole.log(`Progress: ${updateProgress}%`)\n\t\t}\n\n\t\tif (shouldRestart) {\n\t\t\t// TODO: Replace with restartWithModalWarning\n\t\t\twindow.alert(\"RELOADING\")\n\t\t\twindow.location.reload();\n\t\t}\n\t}\n\n\t/**\n\t * Internal API - Expose internal APIs to debug dyna\n\t */\n\tfunction allowDebugging() {\n\t\t// Only for debugging purposes\n\t\twindow.dyna.debug = {};\n\t\twindow.dyna.debug.updatePluginsForced = updateAllPlugins;\n\t\twindow.dyna.debug.updateStore = gatherPluginsFromState;\n\t\twindow.dyna.debug.fetch = fetchWithProgress;\n\t\twindow.dyna.debug.parse = parseAndLoadPlugin;\n\t\twindow.dyna.debug.getPluginInformation = fetchPluginInformation;\n\t}\n\n\t/**\n\t * Dyna plugin API\n\t */\n\twindow.dyna.api = {}\n\n\t/**\n\t * Returns an array of plugins that are using Dyna\n\t * @returns {DynaPlugin[]}\n\t */\n\twindow.dyna.api.getPlugins = function () {\n\t\tconst pluginArray = window.dyna.store.dynaplugins;\n\t\treturn Object.freeze(pluginArray)\n\t}\n\n\t/**\n\t * Check for plugin updates\n\t * @param {string} author - Author of the plugin to search\n\t * @param {string} id - Id of the plugin to search\n\t * @returns {boolean} whether the plugin needs an update or the check has failed\n\t */\n\twindow.dyna.api.checkUpdatesForPlugin = async function (author, id) {\n\t\ttry {\n\t\t\tconst plugin = window.dyna.store.dynaplugins.find(pl => pl.author == author && pl.id == id);\n\n\t\t\t/** @type {DynaPluginInformation} */\n\t\t\tconst information = await fetchPluginInformation(plugin.repo)\n\n\t\t\tif (plugin.version != information.latest && !plugin.dev) {\n\t\t\t\tconsole.log(`[updater] An update has been found for the plugin ${author}/${id}`);\n\t\t\t\treturn true\n\t\t\t}\n\n\t\t\tconsole.log(`[updater] No update has been found...`)\n\t\t\treturn false\n\t\t} catch (error) {\n\t\t\tconsole.error(\"[updater] An error has been thrown:\", error)\n\t\t\treturn false\n\t\t}\n\t}\n\n\tsetInterval(updateAllPlugins, CALCULATED_INTERVAL)\n\tsetTimeout(gatherPluginsFromState, 500) // Let plugins load successfully\n\n\treturn  {\n\t\tonUnload: () => {\n\t\t\t// Unload dyna by removing the update interval and removing all related APIs from the window object\n\t\t\tclearInterval(updateAllPlugins, CALCULATED_INTERVAL)\n\t\t\twindow.dyna = null\n\t\t\tconsole.log(\"DYNA has been unloaded...\")\n\t\t}\n\t}\n}\n"}
